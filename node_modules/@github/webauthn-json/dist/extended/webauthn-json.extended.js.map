{"mappings":"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","sources":["./src/base64url.ts","./src/convert.ts","./src/basic/schema.ts","./src/basic/api.ts","./src/basic/supported.ts","./src/extended/schema.ts","./src/extended/api.ts"],"sourcesContent":["export type Base64urlString = string;\n\nexport function base64urlToBuffer(\n  baseurl64String: Base64urlString,\n): ArrayBuffer {\n  // Base64url to Base64\n  const padding = \"==\".slice(0, (4 - (baseurl64String.length % 4)) % 4);\n  const base64String =\n    baseurl64String.replace(/-/g, \"+\").replace(/_/g, \"/\") + padding;\n\n  // Base64 to binary string\n  const str = atob(base64String);\n\n  // Binary string to buffer\n  const buffer = new ArrayBuffer(str.length);\n  const byteView = new Uint8Array(buffer);\n  for (let i = 0; i < str.length; i++) {\n    byteView[i] = str.charCodeAt(i);\n  }\n  return buffer;\n}\n\nexport function bufferToBase64url(buffer: ArrayBuffer): Base64urlString {\n  // Buffer to binary string\n  const byteView = new Uint8Array(buffer);\n  let str = \"\";\n  for (const charCode of byteView) {\n    str += String.fromCharCode(charCode);\n  }\n\n  // Binary string to base64\n  const base64String = btoa(str);\n\n  // Base64 to base64url\n  // We assume that the base64url string is well-formed.\n  const base64urlString = base64String\n    .replace(/\\+/g, \"-\")\n    .replace(/\\//g, \"_\")\n    .replace(/=/g, \"\");\n  return base64urlString;\n}\n","// We export these values in order so that they can be used to deduplicate\n// schema definitions in minified JS code.\n\nimport { Schema } from \"./schema-format\";\n\n// TODO: Parcel isn't deduplicating these values.\nexport const copyValue = \"copy\";\nexport const convertValue = \"convert\";\n\nexport function convert<From, To>(\n  conversionFn: (v: From) => To,\n  schema: Schema,\n  input: any,\n): any {\n  if (schema === copyValue) {\n    return input;\n  }\n  if (schema === convertValue) {\n    return conversionFn(input);\n  }\n  if (schema instanceof Array) {\n    return input.map((v: any) => convert<From, To>(conversionFn, schema[0], v));\n  }\n  if (schema instanceof Object) {\n    const output: any = {};\n    for (const [key, schemaField] of Object.entries(schema)) {\n      if (!(key in input)) {\n        if (schemaField.required) {\n          throw new Error(`Missing key: ${key}`);\n        }\n        continue;\n      }\n      // Fields can be null (rather than missing or `undefined`), e.g. the\n      // `userHandle` field of the `AuthenticatorAssertionResponse`:\n      // https://www.w3.org/TR/webauthn/#iface-authenticatorassertionresponse\n      if (input[key] == null) {\n        output[key] = null;\n        continue;\n      }\n      output[key] = convert<From, To>(\n        conversionFn,\n        schemaField.schema,\n        input[key],\n      );\n    }\n    return output;\n  }\n}\n\nexport function required(schema: Schema): any {\n  return {\n    required: true,\n    schema,\n  };\n}\n\nexport function optional(schema: Schema): any {\n  return {\n    required: false,\n    schema,\n  };\n}\n","import { Schema } from \"../schema-format\";\nimport {\n  convertValue as convert,\n  copyValue as copy,\n  optional,\n  required,\n} from \"../convert\";\n\n// Shared by `create()` and `get()`.\n\nconst publicKeyCredentialDescriptorSchema: Schema = {\n  type: required(copy),\n  id: required(convert),\n  transports: optional(copy),\n};\n\nconst simplifiedExtensionsSchema: Schema = {\n  appid: optional(copy),\n  appidExclude: optional(copy),\n  credProps: optional(copy),\n};\n\nconst simplifiedClientExtensionResultsSchema = {\n  appid: optional(copy),\n  appidExclude: optional(copy),\n  credProps: optional(copy),\n};\n\n// `navigator.create()` request\n\nexport const credentialCreationOptions: Schema = {\n  publicKey: required({\n    rp: required(copy),\n    user: required({\n      id: required(convert),\n      name: required(copy),\n      displayName: required(copy),\n    }),\n\n    challenge: required(convert),\n    pubKeyCredParams: required(copy),\n\n    timeout: optional(copy),\n    excludeCredentials: optional([publicKeyCredentialDescriptorSchema]),\n    authenticatorSelection: optional(copy),\n    attestation: optional(copy),\n    extensions: optional(simplifiedExtensionsSchema),\n  }),\n  signal: optional(copy),\n};\n\n// `navigator.create()` response\n\nexport const publicKeyCredentialWithAttestation: Schema = {\n  type: required(copy),\n  id: required(copy),\n  rawId: required(convert),\n  response: required({\n    clientDataJSON: required(convert),\n    attestationObject: required(convert),\n  }),\n  clientExtensionResults: required(simplifiedClientExtensionResultsSchema),\n};\n\n// `navigator.get()` request\n\nexport const credentialRequestOptions: Schema = {\n  mediation: optional(copy),\n  publicKey: required({\n    challenge: required(convert),\n    timeout: optional(copy),\n    rpId: optional(copy),\n    allowCredentials: optional([publicKeyCredentialDescriptorSchema]),\n    userVerification: optional(copy),\n    extensions: optional(simplifiedExtensionsSchema),\n  }),\n  signal: optional(copy),\n};\n\n// `navigator.get()` response\n\nexport const publicKeyCredentialWithAssertion: Schema = {\n  type: required(copy),\n  id: required(copy),\n  rawId: required(convert),\n  response: required({\n    clientDataJSON: required(convert),\n    authenticatorData: required(convert),\n    signature: required(convert),\n    userHandle: required(convert),\n  }),\n  clientExtensionResults: required(simplifiedClientExtensionResultsSchema),\n};\n\nexport const schema: { [s: string]: Schema } = {\n  credentialCreationOptions,\n  publicKeyCredentialWithAttestation,\n  credentialRequestOptions,\n  publicKeyCredentialWithAssertion,\n};\n","import { base64urlToBuffer, bufferToBase64url } from \"../base64url\";\nimport { convert } from \"../convert\";\nimport {\n  CredentialCreationOptionsJSON,\n  CredentialRequestOptionsJSON,\n  PublicKeyCredentialWithAssertionJSON,\n  PublicKeyCredentialWithAttestationJSON,\n  PublicKeyCredentialWithClientExtensionResults,\n} from \"./json\";\nimport {\n  credentialCreationOptions,\n  credentialRequestOptions,\n  publicKeyCredentialWithAssertion,\n  publicKeyCredentialWithAttestation,\n} from \"./schema\";\n\nexport function createRequestFromJSON(\n  requestJSON: CredentialCreationOptionsJSON,\n): CredentialCreationOptions {\n  return convert(base64urlToBuffer, credentialCreationOptions, requestJSON);\n}\n\nexport function createResponseToJSON(\n  credential: PublicKeyCredential,\n): PublicKeyCredentialWithAttestationJSON {\n  const credentialWithClientExtensionResults = credential as PublicKeyCredentialWithClientExtensionResults;\n  credentialWithClientExtensionResults.clientExtensionResults = credential.getClientExtensionResults();\n  return convert(\n    bufferToBase64url,\n    publicKeyCredentialWithAttestation,\n    credentialWithClientExtensionResults,\n  );\n}\n\nexport async function create(\n  requestJSON: CredentialCreationOptionsJSON,\n): Promise<PublicKeyCredentialWithAttestationJSON> {\n  const credential = (await navigator.credentials.create(\n    createRequestFromJSON(requestJSON),\n  )) as PublicKeyCredential;\n  return createResponseToJSON(credential);\n}\n\nexport function getRequestFromJSON(\n  requestJSON: CredentialRequestOptionsJSON,\n): CredentialRequestOptions {\n  return convert(base64urlToBuffer, credentialRequestOptions, requestJSON);\n}\n\nexport function getResponseToJSON(\n  credential: PublicKeyCredential,\n): PublicKeyCredentialWithAssertionJSON {\n  const credentialWithClientExtensionResults = credential as PublicKeyCredentialWithClientExtensionResults;\n  credentialWithClientExtensionResults.clientExtensionResults = credential.getClientExtensionResults();\n  return convert(\n    bufferToBase64url,\n    publicKeyCredentialWithAssertion,\n    credentialWithClientExtensionResults,\n  );\n}\n\nexport async function get(\n  requestJSON: CredentialRequestOptionsJSON,\n): Promise<PublicKeyCredentialWithAssertionJSON> {\n  const credential = (await navigator.credentials.get(\n    getRequestFromJSON(requestJSON),\n  )) as PublicKeyCredential;\n  return getResponseToJSON(credential);\n}\n\ndeclare global {\n  interface Window {\n    PublicKeyCredential: PublicKeyCredential | undefined;\n  }\n}\n","// This function does a simple check to test for the credential management API\n// functions we need, and an indication of public key credential authentication\n// support.\n// https://developers.google.com/web/updates/2018/03/webauthn-credential-management\n\nexport function supported(): boolean {\n  return !!(\n    navigator.credentials &&\n    navigator.credentials.create &&\n    navigator.credentials.get &&\n    window.PublicKeyCredential\n  );\n}\n","import {\n  credentialCreationOptions,\n  credentialRequestOptions,\n  publicKeyCredentialWithAssertion,\n  publicKeyCredentialWithAttestation,\n} from \"../basic/schema\";\nimport { convertValue, copyValue, optional, required } from \"../convert\";\nimport { Schema } from \"../schema-format\";\n\n// shared\n\nconst authenticationExtensionsClientInputsSchema: Schema = {\n  appid: optional(copyValue),\n  appidExclude: optional(copyValue),\n  uvm: optional(copyValue),\n  credProps: optional(copyValue),\n  largeBlob: optional({\n    support: optional(copyValue),\n    read: optional(copyValue),\n    write: optional(convertValue),\n  }),\n};\n\nconst authenticationExtensionsClientOutputsSchema: Schema = {\n  appid: optional(copyValue),\n  appidExclude: optional(copyValue),\n  uvm: optional(copyValue),\n  credProps: optional(copyValue),\n  largeBlob: optional({\n    supported: optional(copyValue),\n    blob: optional(convertValue),\n    written: optional(copyValue),\n  }),\n};\n\n// create\n\nexport const credentialCreationOptionsExtended: Schema = JSON.parse(\n  JSON.stringify(credentialCreationOptions),\n);\n(credentialCreationOptionsExtended as any).publicKey.schema.extensions = optional(\n  authenticationExtensionsClientInputsSchema,\n);\n\nexport const publicKeyCredentialWithAttestationExtended: Schema = JSON.parse(\n  JSON.stringify(publicKeyCredentialWithAttestation),\n);\n(publicKeyCredentialWithAttestationExtended as any).clientExtensionResults = required(\n  authenticationExtensionsClientOutputsSchema,\n);\n// get\n\nexport const credentialRequestOptionsExtended: Schema = JSON.parse(\n  JSON.stringify(credentialRequestOptions),\n);\n(credentialRequestOptionsExtended as any).publicKey.schema.extensions = optional(\n  authenticationExtensionsClientInputsSchema,\n);\n\nexport const publicKeyCredentialWithAssertionExtended: Schema = JSON.parse(\n  JSON.stringify(publicKeyCredentialWithAssertion),\n);\n(publicKeyCredentialWithAssertionExtended as any).clientExtensionResults = required(\n  authenticationExtensionsClientOutputsSchema,\n);\n","import { base64urlToBuffer, bufferToBase64url } from \"../base64url\";\nimport {\n  CredentialCreationOptionsJSON,\n  CredentialRequestOptionsJSON,\n  PublicKeyCredentialWithAssertionJSON,\n  PublicKeyCredentialWithAttestationJSON,\n  PublicKeyCredentialWithClientExtensionResults,\n} from \"../basic/json\";\nimport { convert } from \"../convert\";\nimport {\n  CredentialCreationOptionsExtendedJSON,\n  CredentialRequestOptionsExtendedJSON,\n  PublicKeyCredentialWithAssertionExtendedResultsJSON,\n  PublicKeyCredentialWithAttestationExtendedResultsJSON,\n} from \"./json\";\nimport {\n  credentialCreationOptionsExtended,\n  credentialRequestOptionsExtended,\n  publicKeyCredentialWithAssertionExtended,\n  publicKeyCredentialWithAttestationExtended,\n} from \"./schema\";\n\n// create\n\nexport function createExtendedRequestFromJSON(\n  requestJSON: CredentialCreationOptionsExtendedJSON,\n): CredentialCreationOptions {\n  return convert(\n    base64urlToBuffer,\n    credentialCreationOptionsExtended,\n    requestJSON,\n  );\n}\n\nexport function createExtendedResponseToJSON(\n  credential: PublicKeyCredential,\n): PublicKeyCredentialWithAttestationExtendedResultsJSON {\n  const credentialWithClientExtensionResults = credential as PublicKeyCredentialWithClientExtensionResults;\n  credentialWithClientExtensionResults.clientExtensionResults = credential.getClientExtensionResults();\n  return convert(\n    bufferToBase64url,\n    publicKeyCredentialWithAttestationExtended,\n    credentialWithClientExtensionResults,\n  );\n}\n\nexport async function createExtended(\n  requestJSON: CredentialCreationOptionsExtendedJSON,\n): Promise<PublicKeyCredentialWithAttestationJSON> {\n  const credential = (await navigator.credentials.create(\n    createExtendedRequestFromJSON(requestJSON),\n  )) as PublicKeyCredential;\n  return createExtendedResponseToJSON(credential);\n}\n\n// get\n\nexport function getExtendedRequestFromJSON(\n  requestJSON: CredentialRequestOptionsExtendedJSON,\n): CredentialRequestOptions {\n  return convert(\n    base64urlToBuffer,\n    credentialRequestOptionsExtended,\n    requestJSON,\n  );\n}\n\nexport function getExtendedResponseToJSON(\n  credential: PublicKeyCredential,\n): PublicKeyCredentialWithAssertionExtendedResultsJSON {\n  const credentialWithClientExtensionResults = credential as PublicKeyCredentialWithClientExtensionResults;\n  credentialWithClientExtensionResults.clientExtensionResults = credential.getClientExtensionResults();\n  return convert(\n    bufferToBase64url,\n    publicKeyCredentialWithAssertionExtended,\n    credentialWithClientExtensionResults,\n  );\n}\n\nexport async function getExtended(\n  requestJSON: CredentialRequestOptionsJSON,\n): Promise<PublicKeyCredentialWithAssertionJSON> {\n  const credential = (await navigator.credentials.get(\n    getExtendedRequestFromJSON(requestJSON),\n  )) as PublicKeyCredential;\n  return getExtendedResponseToJSON(credential);\n}\n"],"names":["base64urlToBuffer","baseurl64String","padding","slice","length","base64String","replace","str","atob","buffer","ArrayBuffer","byteView","Uint8Array","i","charCodeAt","bufferToBase64url","charCode","String","fromCharCode","btoa","convert","conversionFn","schema","input","Array","map","v","Object","output","key","schemaField","entries","required","Error","optional","publicKeyCredentialDescriptorSchema","type","$d8c599070be9e2f65b1a5697edbece$export$required","id","transports","$d8c599070be9e2f65b1a5697edbece$export$optional","simplifiedExtensionsSchema","appid","appidExclude","credProps","simplifiedClientExtensionResultsSchema","credentialCreationOptions","publicKey","rp","user","name","displayName","challenge","pubKeyCredParams","timeout","excludeCredentials","authenticatorSelection","attestation","extensions","signal","publicKeyCredentialWithAttestation","rawId","response","clientDataJSON","attestationObject","clientExtensionResults","credentialRequestOptions","mediation","rpId","allowCredentials","userVerification","publicKeyCredentialWithAssertion","authenticatorData","signature","userHandle","createRequestFromJSON","requestJSON","$abb68d7d7838f466e0a8e79e6$export$credentialCreationOptions","createResponseToJSON","credential","credentialWithClientExtensionResults","getClientExtensionResults","$abb68d7d7838f466e0a8e79e6$export$publicKeyCredentialWithAttestation","async","create","navigator","credentials","getRequestFromJSON","$abb68d7d7838f466e0a8e79e6$export$credentialRequestOptions","getResponseToJSON","$abb68d7d7838f466e0a8e79e6$export$publicKeyCredentialWithAssertion","get","supported","window","PublicKeyCredential","authenticationExtensionsClientInputsSchema","uvm","largeBlob","support","read","write","authenticationExtensionsClientOutputsSchema","blob","written","credentialCreationOptionsExtended","JSON","parse","stringify","publicKeyCredentialWithAttestationExtended","credentialRequestOptionsExtended","publicKeyCredentialWithAssertionExtended","createExtendedRequestFromJSON","$eb85b67590ea986222c43792f643c5df$export$credentialCreationOptionsExtended","createExtendedResponseToJSON","$eb85b67590ea986222c43792f643c5df$export$publicKeyCredentialWithAttestationExtended","createExtended","getExtendedRequestFromJSON","$eb85b67590ea986222c43792f643c5df$export$credentialRequestOptionsExtended","getExtendedResponseToJSON","$eb85b67590ea986222c43792f643c5df$export$publicKeyCredentialWithAssertionExtended","getExtended"],"version":3,"file":"webauthn-json.extended.js.map"}